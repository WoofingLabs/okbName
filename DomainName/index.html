<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domain Name Launchpad - .okb, .star, .xdog</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link rel="icon" href="https://woofingjace.com/images/jace.png" type="image/x-icon">
    <style>
        :root {
            --primary-color: #ff9100;
            --secondary-color: #ff6f61;
            --gradient-bg: linear-gradient(180deg, #1e1e2f 0%, #2a2a3d 100%);
            --card-bg: #2c2f48;
            --input-bg: #373b5c;
            --text-color: #ffffff;
            --border-radius: 15px;
            --button-active-bg: #e68a00;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Inter', sans-serif;
            background: var(--gradient-bg);
            color: var(--text-color);
            padding: 20px;
            min-height: 100vh;
            line-height: 1.5;
        }
        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 30px;
            background: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        h1 {
            text-align: center;
            font-size: clamp(1.8em, 5vw, 2.5em);
            margin-bottom: 25px;
            font-weight: 700;
            text-transform: uppercase;
            background: linear-gradient(90deg, var(--secondary-color), var(--primary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .section {
            background: var(--input-bg);
            padding: 20px;
            margin-bottom: 20px;
            border-radius: var(--border-radius);
            border: 1px solid var(--primary-color);
        }
        h2 {
            font-size: clamp(1.2em, 3.5vw, 1.6em);
            margin-bottom: 15px;
            font-weight: 600;
            color: var(--primary-color);
        }
        .toggle-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .toggle-button {
            padding: 10px 20px;
            background: var(--input-bg);
            border: none;
            border-radius: var(--border-radius);
            color: var(--text-color);
            font-size: 0.9em;
            cursor: pointer;
            transition: background 0.2s;
            font-family: 'Poppins', sans-serif;
        }
        .toggle-button.active {
            background: var(--primary-color);
        }
        .toggle-button:hover {
            background: var(--button-active-bg);
        }
        .button {
            background: var(--primary-color);
            color: var(--text-color);
            padding: 10px 20px;
            border: none;
            border-radius: var(--border-radius);
            font-weight: 600;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease;
            margin: 5px;
        }
        .button:hover {
            background: var(--button-active-bg);
            transform: translateY(-2px);
        }
        .button:disabled {
            background: #4a4f7a;
            color: #777777;
            cursor: not-allowed;
        }
        input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 1px solid var(--primary-color);
            border-radius: var(--border-radius);
            background: var(--input-bg);
            color: var(--text-color);
            font-size: 1em;
        }
        input::placeholder {
            color: #666666;
        }
        .status {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--primary-color);
            text-align: center;
        }
        .wallet-info {
            color: var(--text-color);
            font-weight: 600;
            word-break: break-all;
        }
        .nft-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .nft-table th, .nft-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #333333;
        }
        .nft-table th {
            background: var(--input-bg);
            color: var(--primary-color);
            font-weight: 600;
        }
        .view-btn {
            background: var(--primary-color);
            color: var(--text-color);
            padding: 6px 12px;
            font-size: 0.85em;
            border-radius: var(--border-radius);
            border: none;
            cursor: pointer;
        }
        .view-btn:hover {
            background: var(--button-active-bg);
        }
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }
        .nft-preview {
            margin-top: 15px;
            text-align: center;
        }
        .nft-preview img {
            max-width: 100%;
            border: 1px solid var(--primary-color);
            border-radius: var(--border-radius);
        }
        .output-box {
            background: var(--input-bg);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            word-break: break-all;
            font-size: 0.9em;
            color: var(--text-color);
        }
        .output-box label {
            display: block;
            font-size: 0.9em;
            margin-bottom: 5px;
            color: var(--primary-color);
        }
        .dog-section {
            text-align: center;
            margin-top: 20px;
        }
        .dog-section img {
            width: 60px;
            height: 60px;
            margin-bottom: 10px;
        }
        .dog-message {
            font-size: 0.9em;
            color: var(--secondary-color);
            font-style: italic;
            font-family: 'Poppins', sans-serif;
        }
        .footer {
            text-align: center;
            margin-top: 30px;
            font-size: 0.85em;
            color: #666666;
        }
        .footer a {
            color: var(--primary-color);
            text-decoration: none;
        }
        .footer a:hover {
            text-decoration: underline;
        }
        @media (max-width: 768px) {
            .container { padding: 15px; }
            .section { padding: 15px; }
            .button, .toggle-button { width: 100%; padding: 12px; margin: 8px 0; }
            .nft-table { display: block; overflow-x: auto; }
            .nft-table th, .nft-table td { font-size: 0.85em; padding: 10px; }
            .nft-table tr { display: block; margin-bottom: 10px; border-bottom: 1px solid #333333; }
            .nft-table td { display: block; text-align: left; }
            .nft-table td button { width: 100%; margin: 5px 0; }
            .dog-section img { width: 50px; height: 50px; }
            .dog-message { font-size: 0.8em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Domain Name Launchpad</h1>
        <div class="section">
            <h2>Connect to X Layer</h2>
            <button id="connectButton" class="button">Connect Wallet</button>
            <p>Wallet: <span id="walletAddress" class="wallet-info">Not connected</span></p>
            <div id="networkStatus" class="status">Click to connect...</div>
        </div>
        <div class="section" id="mintDomainSection">
            <h2>Mint Domain Name</h2>
            <div class="toggle-buttons">
                <button class="toggle-button active" id="okbButton" onclick="selectDomain('okb')">.okb</button>
                <button class="toggle-button" id="starButton" onclick="selectDomain('star')">.star</button>
                <button class="toggle-button" id="xdogButton" onclick="selectDomain('xdog')">.xdog</button>
            </div>
            <input type="text" id="domainId" placeholder="Domain ID (e.g., jace123)" oninput="convertToHex()">
            <div class="output-box">
                <label>Hex Data</label>
                <span id="hexOutputText">Enter a domain name to see the hex data</span>
            </div>
            <button id="copyHexButton" class="button" onclick="copyToClipboard('hex')">Copy Hex Data</button>
            <button id="mintDomain" class="button">Mint Domain NFT</button>
            <div class="output-box">
                <label>Contract Address</label>
                <span id="contractAddress">0xBf13Ed020DCF22bc8216A23A1167A5dD1fDC2D0E</span>
            </div>
            <button id="copyAddressButton" class="button" onclick="copyToClipboard('address')">Copy Contract Address</button>
            <div id="mintStatus" class="status"></div>
        </div>
        <div class="section" id="myDomainsSection">
            <h2>My Domains</h2>
            <button id="fetchMyDomains" class="button">Fetch My Domains</button>
            <table class="nft-table">
                <thead>
                    <tr>
                        <th>Token ID</th>
                        <th>Domain Name</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="domainsBody"></tbody>
            </table>
            <div id="domainsStatus" class="status"></div>
            <div class="nft-preview" id="nftPreview" style="display: none;">
                <h2>NFT Preview</h2>
                <img id="nftImage" src="" alt="NFT Preview">
            </div>
        </div>
        <div class="dog-section">
            <img src="https://static.oklink.com/cdn/assets/imgs/235/4EC890FA53A98FFF.png" alt="WoofingJace">
            <div class="dog-message" id="dogMessage">"Woof! Select a domain and enter a name to mint or convert!"</div>
        </div>
        <div class="footer">
            Powered by <a href="https://www.okx.com/web3/explorer/xlayer" target="_blank">X Layer</a> | Domain Name Launchpad © 2025
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script>
        let web3, accounts, domainContract;
        let selectedDomain = 'okb'; // Default to .okb

        const contracts = {
            okb: {
                address: '0xBf13Ed020DCF22bc8216A23A1167A5dD1fDC2D0E',
                suffix: 'okb',
                protocol: 'okbname',
                currency: 'OKB'
            },
            star: {
                address: '0xfD809E6c00b7ABD737C3FaDFCaFAF4b6564AF9dD',
                suffix: 'star',
                protocol: 'starname',
                currency: 'ETH'
            },
            xdog: {
                address: '0x68B6387628b4096af034c3a9de3073AB18E744C2',
                suffix: 'xdog',
                protocol: 'xdogname',
                currency: 'ETH'
            }
        };

        const domainContractABI = [
            {
                "inputs": [
                    { "internalType": "string", "name": "_id", "type": "string" }
                ],
                "name": "mint",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "anonymous": false,
                "inputs": [
                    { "indexed": true, "internalType": "address", "name": "minter", "type": "address" },
                    { "indexed": false, "internalType": "uint256", "name": "tokenId", "type": "uint256" },
                    { "indexed": false, "internalType": "string", "name": "id", "type": "string" }
                ],
                "name": "Minted",
                "type": "event"
            },
            {
                "inputs": [
                    { "internalType": "uint256", "name": "tokenId", "type": "uint256" }
                ],
                "name": "tokenName",
                "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "uint256", "name": "tokenId", "type": "uint256" }
                ],
                "name": "tokenURI",
                "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "address", "name": "owner", "type": "address" },
                    { "internalType": "uint256", "name": "index", "type": "uint256" }
                ],
                "name": "tokenOfOwnerByIndex",
                "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalSupply",
                "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "name",
                "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "symbol",
                "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "SUFFIX",
                "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "string", "name": "", "type": "string" }
                ],
                "name": "idsMintedLower",
                "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "address", "name": "owner", "type": "address" }
                ],
                "name": "balanceOf",
                "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "address", "name": "", "type": "address" }
                ],
                "name": "ownerToTokenId",
                "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        const xLayer = {
            chainId: 196,
            name: 'X Layer mainnet',
            explorerUrl: 'https://www.okx.com/web3/explorer/xlayer',
            rpcUrl: 'https://rpc.xlayer.tech'
        };

        const dogMessages = {
            default: (suffix) => [
                `Woof! Enter a name to get its hex for ${suffix.toUpperCase()} domain registration!`,
                `Arf! Type a domain, and I’ll fetch the hex for .${suffix}, pup!`,
                `Bow wow! Let’s convert that name to hex for .${suffix}, Jace style!`,
                `Yip yip! Ready to sniff out your .${suffix} domain’s hex code!`
            ],
            invalid: [
                "Grrr... Only letters and numbers, pup! Try again!",
                "Woof? That name’s got weird chars, stick to alphanumerics!",
                "Arf! Name’s too long or empty, keep it 1-15 chars, hooman!",
                "Ruff! Invalid name, use letters and numbers only, Jace pal!"
            ],
            success: (name, suffix) => [
                `Arf arf! Hex for ${name}.${suffix} is ready, pup!`,
                `Woof! Got the hex for ${name}.${suffix}, let’s register it!`,
                `Bow wow! ${name}.${suffix} hex is fetched, copy it, hooman!`,
                `Yip! Hex for ${name}.${suffix} is here, ready to roll!`
            ],
            copied: (type) => [
                `Woof woof! ${type === 'hex' ? 'Hex data' : 'Contract address'} copied to clipboard, pup!`,
                `Arf! Copied the ${type === 'hex' ? 'hex' : 'address'}, go register that domain!`,
                `Bow wow! ${type === 'hex' ? 'Hex' : 'Address'} is in your clipboard, Jace champ!`,
                `Yip yip! ${type === 'hex' ? 'Hex' : 'Address'} copied, you’re pawsome, hooman!`
            ],
            copyFailed: (type) => [
                `Grrr... ${type === 'hex' ? 'Hex data' : 'Contract address'} copy failed! Try selecting and copying manually, Jace friend!`,
                `Woof? Couldn’t copy the ${type === 'hex' ? 'hex' : 'address'}! Select the text manually, pup!`,
                `Arf! Clipboard’s hiding the ${type === 'hex' ? 'hex' : 'address'}! Try manual copy, hooman!`,
                `Ruff! ${type === 'hex' ? 'Hex' : 'Address'} copy didn’t work! Select and copy manually!`
            ]
        };

        function getRandomMessage(type, param1, param2) {
            const messages = dogMessages[type];
            if (typeof messages === 'function') {
                const options = messages(param1, param2);
                return options[Math.floor(Math.random() * options.length)];
            }
            return messages[Math.floor(Math.random() * messages.length)];
        }

        async function connectWallet() {
            const status = document.getElementById('networkStatus');
            try {
                if (!window.ethereum) {
                    status.innerHTML = 'No wallet detected. Please install <a href="https://metamask.io" target="_blank">MetaMask</a>.';
                    throw new Error("No wallet detected");
                }
                status.innerText = "Connecting...";
                web3 = new Web3(window.ethereum);
                accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts.length) {
                    throw new Error("Please unlock your wallet or connect it.");
                }
                const chainId = await web3.eth.getChainId();
                if (chainId !== 196) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0xc4' }]
                        });
                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0xc4',
                                    chainName: 'X Layer mainnet',
                                    nativeCurrency: { name: 'OKB', symbol: 'OKB', decimals: 18 },
                                    rpcUrls: ['https://rpc.xlayer.tech'],
                                    blockExplorerUrls: ['https://www.okx.com/web3/explorer/xlayer']
                                }]
                            });
                        } else {
                            throw switchError;
                        }
                    }
                }
                document.getElementById('walletAddress').innerText = `${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}`;
                domainContract = new web3.eth.Contract(domainContractABI, contracts[selectedDomain].address);
                status.innerText = "Connected to X Layer";
                fetchMyDomains();
            } catch (error) {
                console.error(error);
                status.innerText = "Failed to connect: " + error.message;
            }
        }

        function selectDomain(domain) {
            selectedDomain = domain;
            const okbButton = document.getElementById('okbButton');
            const starButton = document.getElementById('starButton');
            const xdogButton = document.getElementById('xdogButton');
            const contractAddress = document.getElementById('contractAddress');
            const status = document.getElementById('mintStatus');
            const dogMessage = document.getElementById('dogMessage');

            // Update button states
            okbButton.classList.toggle('active', domain === 'okb');
            starButton.classList.toggle('active', domain === 'star');
            xdogButton.classList.toggle('active', domain === 'xdog');

            // Update contract address
            contractAddress.textContent = contracts[domain].address;

            // Update domain contract if wallet is connected
            if (web3 && accounts) {
                domainContract = new web3.eth.Contract(domainContractABI, contracts[domain].address);
            }

            // Reset input and trigger conversion
            document.getElementById('domainId').value = '';
            status.textContent = '';
            dogMessage.textContent = getRandomMessage('default', contracts[domain].suffix);
            convertToHex();
        }

        function isValidString(str) {
            const strBytes = new TextEncoder().encode(str);
            if (strBytes.length === 0 || strBytes.length > 15) return false;
            for (let i = 0; i < strBytes.length; i++) {
                const char = strBytes[i];
                if (
                    !(char >= 48 && char <= 57) && // 0-9
                    !(char >= 65 && char <= 90) && // A-Z
                    !(char >= 97 && char <= 122) // a-z
                ) return false;
            }
            return true;
        }

        function convertToHex() {
            const input = document.getElementById('domainId').value.trim();
            const output = document.getElementById('hexOutputText');
            const status = document.getElementById('mintStatus');
            const dogMessage = document.getElementById('dogMessage');
            const copyHexButton = document.getElementById('copyHexButton');

            if (!input) {
                output.textContent = 'Enter a domain name to see the hex data';
                output.dataset.hex = '';
                status.textContent = '';
                dogMessage.textContent = getRandomMessage('default', contracts[selectedDomain].suffix);
                copyHexButton.disabled = true;
                return;
            }

            if (!isValidString(input)) {
                output.textContent = 'Invalid input: Use letters and numbers only, 1-15 characters';
                output.dataset.hex = '';
                status.textContent = 'Invalid input';
                dogMessage.textContent = getRandomMessage('invalid');
                copyHexButton.disabled = true;
                fetchMyDomains();
                return;
            }

            const inscription = `data:,{"p":"${contracts[selectedDomain].protocol}","op":"reg","name":"${input}.${contracts[selectedDomain].suffix}"}`;
            const hexData = '0x' + Array.from(new TextEncoder().encode(inscription))
                .map(byte => byte.toString(16).padStart(2, '0'))
                .join('');
            output.textContent = hexData;
            output.dataset.hex = hexData;
            status.textContent = `Hex data for ${input}.${contracts[selectedDomain].suffix} generated`;
            dogMessage.textContent = getRandomMessage('success', input, contracts[selectedDomain].suffix);
            copyHexButton.disabled = false;
            fetchMyDomains();
        }

        function copyToClipboard(type) {
            const status = document.getElementById('mintStatus');
            const dogMessage = document.getElementById('dogMessage');
            let textToCopy;
            let sourceElement;

            if (type === 'hex') {
                sourceElement = document.getElementById('hexOutputText');
                textToCopy = sourceElement.dataset.hex || '';
            } else {
                sourceElement = document.getElementById('contractAddress');
                textToCopy = sourceElement.textContent;
            }

            if (!textToCopy || textToCopy === 'Enter a domain name to see the hex data' || textToCopy === 'Invalid input: Use letters and numbers only, 1-15 characters') {
                status.textContent = `No valid ${type === 'hex' ? 'hex data' : 'address'} to copy`;
                dogMessage.textContent = getRandomMessage('copyFailed', type);
                return;
            }

            if (navigator.clipboard && navigator.clipboard.write) {
                navigator.clipboard.write(textToCopy).then(() => {
                    status.textContent = `${type === 'hex' ? 'Hex data' : 'Contract address'} copied to clipboard`;
                    dogMessage.textContent = getRandomMessage('copied', type);
                }).catch((error) => {
                    console.error(`Clipboard API copy ${type} failed:`, error);
                    tryFallbackCopy(textToClip
board, type, status, dogMessage);
                });
            } else {
                tryFallbackCopy(textToClipboard, type, status, dogMessage);
            }
        }

        function tryFallbackCopy(text, type, status, dogMessage) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    status.textContent = `${type === 'hex' ? 'Hex data' : 'Contract address'} copied to clipboard`;
                    dogMessage.textContent = getRandomMessage('copied', type);
                } else {
                    throw new Error('execCommand copy failed');
                }
            } catch (error) {
                console.error(`Fallback copy ${type} failed:`, error);
                status.textContent = `Failed to copy ${type === 'hex' ? 'hex data' : 'contract address'}. Select and copy manually.`;
                dogMessage.textContent = getRandomMessage('copyFailed', type);
            } finally {
                document.body.removeChild(textArea);
            }
        }

        async function mintDomain() {
            const section = document.getElementById('mintDomainSection');
            const status = document.getElementById('mintStatus');
            const dogMessage = document.getElementById('dogMessage');
            const domainId = document.getElementById('domainId').value.trim();
            if (!domainId || domainId.length > 15 || !/^[a-zA-Z0-9]+$/.test(domainId)) {
                status.innerText = "Invalid Domain ID. Use 1-15 alphanumeric characters.";
                dogMessage.textContent = getRandomMessage('invalid');
                return;
            }
            if (!accounts) {
                status.innerText = "Please connect your wallet first!";
                dogMessage.textContent = "Woof? Connect your wallet first, pup!";
                return;
            }
            try {
                section.classList.add('loading');
                status.innerText = "Checking domain availability...";
                const domainIdLower = domainId.toLowerCase();
                const isMinted = await domainContract.methods.idsMintedLower(domainIdLower).call();
                if (isMinted) {
                    status.innerText = "Domain ID already minted!";
                    dogMessage.textContent = `Arf! ${domainId}.${contracts[selectedDomain].suffix} is already taken, pup!`;
                    return;
                }
                const hasMinted = await domainContract.methods.ownerToTokenId(accounts[0]).call();
                if (hasMinted != 0) {
                    status.innerText = "This address has already minted a domain!";
                    dogMessage.textContent = "Ruff! You’ve already got a domain, hooman!";
                    return;
                }
                status.innerText = "Minting domain NFT...";
                const gas = await domainContract.methods.mint(domainId).estimateGas({ from: accounts[0] }).catch(() => 600000);
                const tx = await domainContract.methods.mint(domainId).send({
                    from: accounts[0],
                    gas: Math.floor(gas * 1.2)
                });
                status.innerHTML = `Domain minted! Token ID: ${tx.events.Minted.returnValues.tokenId} (<a href="${xLayer.explorerUrl}/token/${contracts[selectedDomain].address}?a=${tx.events.Minted.returnValues.tokenId}" target="_blank">View on Explorer</a>)`;
                dogMessage.textContent = getRandomMessage('success', domainId, contracts[selectedDomain].suffix);
                document.getElementById('domainId').value = '';
                fetchMyDomains();
            } catch (error) {
                console.error(error);
                status.innerText = "Failed to mint domain: " + (error.message.includes('revert') ? error.message.split('revert')[1]?.trim() || 'Unknown reason' : error.message);
                dogMessage.textContent = `Grrr... Minting failed, pup! Try again!`;
            } finally {
                section.classList.remove('loading');
            }
        }

        async function fetchMyDomains() {
            if (!accounts) {
                document.getElementById('domainsStatus').innerText = "Please connect your wallet first!";
                document.getElementById('dogMessage').textContent = "Woof? Connect your wallet first, pup!";
                return;
            }
            const section = document.getElementById('myDomainsSection');
            const status = document.getElementById('domainsStatus');
            const dogMessage = document.getElementById('dogMessage');
            try {
                section.classList.add('loading');
                status.innerText = "Fetching your domains...";
                const domainsBody = document.getElementById('domainsBody');
                domainsBody.innerHTML = '';
                let foundDomains = false;
                for (const domain in contracts) {
                    const contract = new web3.eth.Contract(domainContractABI, contracts[domain].address);
                    const balance = await contract.methods.balanceOf(accounts[0]).call();
                    if (balance > 0) {
                        const tokenId = await contract.methods.tokenOfOwnerByIndex(accounts[0], 0).call();
                        const tokenName = await contract.methods.tokenName(tokenId).call();
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${tokenId}</td>
                            <td>${tokenName}</td>
                            <td>
                                <button class="view-btn" onclick="viewNFT(${tokenId}, '${domain}')">View</button>
                            </td>
                        `;
                        domainsBody.appendChild(row);
                        foundDomains = true;
                    }
                }
                status.innerText = foundDomains ? "Domains loaded successfully!" : "No domains minted yet!";
                dogMessage.textContent = foundDomains ? "Woof! Here are your domains, pup!" : "Arf! No domains yet, let’s mint one!";
            } catch (error) {
                console.error(error);
                status.innerText = "Failed to fetch domains: " + error.message;
                dogMessage.textContent = "Grrr... Couldn’t fetch domains, pup! Try again!";
            } finally {
                section.classList.remove('loading');
            }
        }

        async function viewNFT(tokenId, domain) {
            try {
                const contract = new web3.eth.Contract(domainContractABI, contracts[domain].address);
                const tokenURI = await contract.methods.tokenURI(tokenId).call();
                const json = JSON.parse(atob(tokenURI.split(',')[1]));
                document.getElementById('nftImage').src = json.image;
                document.getElementById('nftPreview').style.display = 'block';
                document.getElementById('dogMessage').textContent = `Woof! Showing NFT for ${json.name}, pup!`;
            } catch (error) {
                console.error(error);
                document.getElementById('domainsStatus').innerText = "Failed to load NFT preview: " + error.message;
                document.getElementById('dogMessage').textContent = "Arf! Couldn’t load NFT preview, hooman!";
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('copyHexButton').disabled = true;
            document.getElementById('copyAddressButton').disabled = false;
            document.getElementById('connectButton').addEventListener('click', connectWallet);
            document.getElementById('mintDomain').addEventListener('click', mintDomain);
            document.getElementById('fetchMyDomains').addEventListener('click', fetchMyDomains);
            if (!window.location.protocol.startsWith('http')) {
                document.getElementById('networkStatus').innerHTML = 'Please run this page via a local server (e.g., "npx serve") to connect MetaMask.';
            } else if (!window.ethereum) {
                document.getElementById('networkStatus').innerHTML = 'No wallet detected. Please install <a href="https://metamask.io">MetaMask</a>.';
            }
        });
    </script>
</body>
</html>
